# MySQL优化

## 列选取原则

- 字段类型的优先级

  整型 > datetime > char,varchar > blob

  整型,datetime运算快，节省空间

  char/varchar 需要考虑字符集的转换与排序时候的校读集，相对较慢

  blog无法使用内存临时表

- 够用即可

  大的字段不仅浪费内存且影响速度，tinyint,smallint,int

  PS:varchar(20)跟varchar(1000)存储同样内容，联表查询时候varchar(1000)消耗更多内存

- 尽量避免使用NULL

  NULL不利用索引，要用特殊的字节来标注，占用更多的磁盘空间

  查询的时候也不方便，要使用 IS NULL, IS NOT NULL来表示

- 慎用ENUM

  ENUM也就是行数据的取值为限定范围内的值

  - 如果sql_mode为非严格模式，在 ENUM 列中插入无效值（即，允许值列表中不存在的字符串），则会插入空字符串 ( `''` ) 作为特殊错误值，当然这是开发时产生的bug；如果sql_mode为严格模式，会报错。故在使用上应多加小心。

  - 当新增ENUM类型值的时候需要修改数据库结构定义，这个代价相对较大，特别是数据量特别大的时候，修改数据库结构定义消耗的系统资源更多，很容易影响生产环境的稳定性
  - 在与char/varchar类型关联的时候，需要做转换，需要耗时，速度比enum->enum,char->char慢。

  当然ENUM也有不少好处：

  - 因为 ENUM 列一般都是有限的值，且都是事先定义好的，所以存储的数据非常紧凑
  - ENUM内部存储的是整型，速度更快，enum列与enum列相关联速度最快
  - 更好的可读性，虽然存的是数字，但在输入和输出时使用的都是对应的允许值

## 索引

- B-tree索引，myisam，innodb

  

- T-tree索引

  NDB引擎

- Hash索引

  Memory使用的是Hash，Hash的理论查询速度为O(1),但是Hash索引存在如下问题：

  - hash函数计算后的结果是随机的。
  - 无法进行范围查找及排序。
  - 无法利用前缀索引，还是因为随机的原因，hash("mysql")、hash("mysql索引")两者关系仍是随机的。

### 复合索引左前缀规则



### 聚簇索引

- myisam的索引指向的是对物理行的引用

- innodb的索引指向的是对主键的引用

### 索引覆盖

索引覆盖：如果sql查询的字段刚好是索引的一部分，那么查询只需要在索引文件上进行不需要回行查找，成为索引覆盖

### 索引长度



### 索引排序

### 冗余与重复

### 碎片修复

## 查询效果分析

### 子查询

### exists 子查询

### in子查询

## 其他

## MySQL集群

### 主从

### 主主